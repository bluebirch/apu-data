---
title: "Analys av APU-data"
author: "Stefan Björk"
fontsize: 12pt
output:
  pdf_document:
    latex_engine: xelatex
    number_sections: yes
    pandoc_args:
      - "--filter"
      - "pandoc-crossref"
  html_document:
    pandoc_args:
      - "--filter"
      - "pandoc-crossref"
mainfont: Minion Pro
monofont: Consolas
lang: sv-SE
papersize: a4
bibliography:
  - ../../bibliography/papers.bib
  - ../../bibliography/books.bib
csl: apa.csl
---

# Inledning

Detta är en ny analys av de data som samlades in från Arbetsförmedlingens testcenter 2012--2016. Den tidigare analysen redovisades i rapporten *Testdata från APU på Arbetsförmedlingen 2012--2016* av Marcus Lindskog, Nicklas Timstedt och Maria Öhrstedt.

## Datainsamling

Från rapporten *Testdata från APU*:

> Förfrågan om att samla in data gick ut till samtliga testcentrum på Arbetsförmedlingen under senare delen av 2016. Resultat från tester som inte är datoriserade har testcentrumen inte anmodats att skicka in, då det arbetet skulle blivit för omfattande. Detta gäller exempelvis DLS och Rey Complex Figure Test.
>
> Data från enstaka testcentrum har inte kommit med i underlaget. Vissa testcentrum hade också problem att exportera WTS data. Testdata från äldre versioner av WTS har inte fungerat att exportera. Efter några försök med alternativa instruktioner för export som inte heller fungerade beslöt Enheten Strategi att vi redan hade tillräckligt med testdata. Inskickade data har sammanfogats och rensats från ovidkommande uppgifter av Johannes Bengtsson, Ar Enheten Sdh, syd. [@LindskogTimstedtOhrstedt2017 3]

## Databearbetning och analys

### Tidigare analyser

I rapporten *Testdata från APU* användes statistikverktyget R:

> Data har importerats till Excel och analys har sedan utförts i statistikprogrammet R. Fredrik Jansson Dahlén och Petra Ornstein på Enheten Forskning och Utveckling, Analysavdelningen, har varit behjälplig i arbetet med att ta fram statistiskt underlag. [@LindskogTimstedtOhrstedt2017 3]

Någon närmare information om vilka analyser som gjordes, hur databearbetning, rensning och liknande har jag inte. Inte heller har jag frågat efter de R-script som rimligen måste finnas kvar på Analysavdelningen. Jag har helt enkelt valt att börja om från början.

### Mina analyser

Min ingång härär att all databearbetning och alla analyser skall vara dokumenterade och sårbara. All "städning" av rådata skall vara dokumenterad och reproducerbar. Därför har jag utgått från det rådata i form av Excel-filer som jag fått tillgång till och gör varje steg i bearbetningen med hjälp av det som förr i tiden benämndes ADB, *automatisk databehandling*. Bearbetningen har gått till i följande steg:

1. Excelfilerna konverterades till CSV (*comma-separated values*) med hjälp av ett litet program i Python (så fick jag samtidigt en anledning att öva mig i Python-programmering). CSV-filer har den fördelen att de är lätta att läsa in i såväl R som Excel.
2. De enskilda CSV-filerna kombinerades till en sammanslagen CSV-fil med data från alla tre testsystem (VTS, ATS och HTS). Här gjorde jag stora ansträngningar att få till läsbara variabelnamn anpassade till R-nomenklatur. Excel-datum har också konverterats till vanliga datum. Under bearbetningen noterade jag följande:
    1. I flera datafiler förekommer testpersonkoden TP999, ofta flera gånger. Jag vet inte vad den betyder och jag har helt enkelt ignorerat dem.
    2. Det förekommer dubletter av testpersonkoder från olika testcenter. Detta löste jag genom att förse varje testperson med ett nummer för testcentret i fråga. Detta nummer är taget från det nummer som förekommer i filnamnet i rådata. Så har dubletten av till exempel testperson *NVA1449038* i både testcentrum 14 och 15 lösts genom att de fått koderna *NVA1449038/14* respektive *NVA1449038/15*.
    3. Den sammanslagna CSV-filen har lästs in i R och dataintegritet och liknande har unersökts med hjälp av R. *Detta dokument är en redovisning av just den integritetsanalysen*.
    
# Integritetsanalys

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
options(knitr.kable.NA = '')
```

## Preliminära datakonverteringar

Det första steget är att läsa in själva datafilen:

```{r read}
af <- read.csv("DATA.csv", encoding="UTF-8")
```

Eftersom datum läses in som faktorer måste de konverteras till datum. Detta görs enklast med hjälp av `lubridate`

```{r dateconv, message=FALSE}
library(lubridate)
af$ats.date <- ymd(af$ats.date)
af$hts.date <- ymd(af$hts.date)
af$vts.birthdate <- ymd(af$vts.birthdate)
```

## Antal testpersoner

```{r echo=FALSE}
N <- nrow(af)
```

Datafilen innehåller `r N` individer, vilket skall jämföras med *Testdata från APU* som innehåller 5680 individer. Jag har alltså fått med `r N-5680` fler individer. Hur det kan komma sig vet jag inte.

## Ålder och datumangivelser

Testpersonernas ålder finns (såvitt jag förstått) inte angiven någonstans utan måste beräknas utifrån födelsedatum och testdatum. Testdatum finns tillgängligt för ATS (`ats.date`) och HTS (`hts.date`). VTS saknar uppgift om testdatum. I VTS finns däremot testpersonens födelsedatum (`vts.birthdate`) och i ATS födelseår (`ats.birthyr`). HTS saknar uppgift om födelsedatum.

### Felregistreringar av födelseår i ATS

Bland födelseåren förekommer årtalet 1872 som är en uppenbar felregistrering och alla årtal före 1900 kan utan vidare rensas ut:

```{r}
af$ats.birthyr[af$ats.birthyr < 1900]<- NA
```

Fördelningen av födelseår i ATS är dock märklig.

```{r fig.cap="Fördelning av årtal i `ats.birthyr` efter städning.", echo=FALSE}
plot(factor(af$ats.birthyr,
            levels=min(na.omit(af$ats.birthyr)):max(na.omit(af$ats.birthyr))))
```

Årtalen 1980 och 1990 sticker ut avsevärt. Detta omnämns också i *Testdata från APU*:

> I ATS systemet är "man", födelseår "1980", "svensk" och utbildningsnivå "okänd" förinställt. Det är mycket hög frekvens av detta födelseår i materialet, vilket tolkas som att man på testcentrum (TC) i många fall inte lagt in verklig ålder utan låtit default-inställningen registreras. [@LindskogTimstedtOhrstedt2017 4]

Enligt @LindskogTimstedtOhrstedt2017 är alltså årtalet 1980 inte att lita på, men deta gäller även årtalet 1990. Detta framgår om man jämför hur födelseår registrerats i ATS respektive VTS. 
```{r}
af$birthyear_valid <- af$ats.birthyr - year(af$vts.birthdate) == 0
t.invalid_year <- af[af$birthyear_valid==FALSE & !is.na(af$birthyear_valid),
                     c('tp','ats.birthyr','vts.birthdate')]
```

Tabellen `t.invalid_year` innehåller nu alla testpersoner där födelseår inte överensstämmer mellan ATS ovh VTS. Eftersom tabellen innehåller `r nrow(t.invalid_year)` rader återges den inte här. Bland differenserna märks dock en kraftig överrepresentation av årtalen 1980 och 1990:

```{r echo=FALSE, message=FALSE}
library(plyr)
t.year <- count(t.invalid_year,vars="ats.birthyr")
kable(head(t.year[with(t.year, order(-freq)),],n=10),row.names=FALSE,
      caption="De tio vanligaste årtalen som skiljer mellan ATS och VTS.")
```

Att hela `r t.year[t.year$ats.birthyr==1990,2]` differenser för just årtalet 1990 skulle vara slumpmässiga felregistreringar förefaller synnerligen osannolikt. Således drar jag slutsatsen att såväl årtalen 1980 som 1990 är otillförlitliga i `ats.birthyr` och dessa rensas därför bort:

```{r clean.ats.birthyr, message=FALSE}
af$ats.birthyr[af$ats.birthyr==1980 | af$ats.birthyr==1990] <- NA
```

Fördelningen av födelseår i `ats.birthyr` innehåller nu två luckor, men en del av de luckorna fylls igen av födelsedatum från `vts.birthdate`.

```{r fig.cap="Fördelning av årtal i `ats.birthyr` efter städning.", echo=FALSE}
plot(factor(af$ats.birthyr,
            levels=min(na.omit(af$ats.birthyr)):max(na.omit(af$ats.birthyr))))
```

### Testdatum

Datum för testning finns i ATS och HTS, men inte i VTS. Det är snarare regel än undantag att testerna sker på samma dag, och därför kan antalet dagar mellan testtillfällena beräknas:

```{r}
diff.ats.hts <- abs(as.numeric(na.omit(af$ats.date-af$hts.date)))
```

För `r length(diff.ats.hts)` personer finns testdatum för både ATS och HTS. För `r length(diff.ats.hts[diff.ats.hts==0])` av dessa är differensen 0 dagar, dvs. testerna ATS och HTS genomfördes samma dag. För resterande testpersoner är mediandifferensen `r median(diff.ats.hts[diff.ats.hts>0])` och medeldifferensen `r mean(diff.ats.hts[diff.ats.hts>0])` vilket antyder en kraftigt sned fördelning. För `r length(diff.ats.hts[diff.ats.hts>30])` testpersoner är differensen större än 30 dagar -- och för `r length(diff.ats.hts[diff.ats.hts>100])` testpersoner större än 100 dagar -- och det finns anledning att fråga sig varför hur det kan komma sig att så många inte testats inom loppet av en månad.

### Beräkning av ålder

Eftersom testpersonernas ålder inte finns angiven någonstans måste den beräknas med hjälp av födelseår/födelsedatum respektive datum för testning. För födelsedatum används i första hand `vts.birthdate`, dels för att det är ett fullständigt datum, dels för att det är mer tillförlitligt än `ats.birthyr`. För testpersoner där `vts.birthdate` saknas men `ats.birthyr` finns sätts födelsedatum till den första juli angivet år för att balansera avsaknaden av dag och månad.

```{r birthdate}
af$birthdate <- af$vts.birthdate
af$birthdate[is.na(af$birthdate) & !is.na(af$ats.birthyr)] <-
  ymd(paste0(af$ats.birthyr[is.na(af$birthdate) & !is.na(af$ats.birthyr)],
             "-07-01"))
```

Om både `ats.date` respektive `hts.date` finns angivet anges testdatum som den dag som infaller mittemellan de båda datumen. I annat fall anges `ats.date` eller `hts.date` beroende på vilken uppgift som råkar finnas tillgänglig.

```{r date}
af$date <- af$hts.date + (af$ats.date - af$hts.date) / 2
af$date[is.na(af$date) & !is.na(af$ats.date)] <- 
  af$ats.date[is.na(af$date) & !is.na(af$ats.date)]
af$date[is.na(af$date) & !is.na(af$hts.date)] <- 
  af$hts.date[is.na(af$date) & !is.na(af$hts.date)]
```

Och nu kan alltså testpersonernas ålder beräknas. För att beräkna tidsspannet mellan två tidpunkter i år behöver vi dock definera en egen funktion^[Se <https://stackoverflow.com/questions/3611314/calculating-ages-in-r>.]:

```{r}
age = function(from, to) {
  from_lt = as.POSIXlt(from)
  to_lt = as.POSIXlt(to)
  age = to_lt$year - from_lt$year
  ifelse(to_lt$mon < from_lt$mon |
           (to_lt$mon == from_lt$mon & to_lt$mday < from_lt$mday),
         age - 1, age)
}
af$age <- age(af$birthdate, af$date)
```

```{r}
# Referens till personen som är 14 år
x <- af$age == 14 & !is.na(af$age)
```


Detta ger en åldersfördelning som speglar fördelningen av födelseår, vilket förefaller rimligt. Att den yngsta testade personen skulle vara 14 år är däremot orimligt eftersom man måste vara minst 16 år för att vara inskriven vid Arbetsförmedlingen. Detta gäller testperson `r af$tp[x]` där födelsedatum är `r af$birthdate[x]` och testdatum `r af$date[x]` (`ats.date`=`r af$ats.date[x]` och `hts.date`=`r af$hts.date[x]`). Födelsedatum kommer från `ats.birthyr` (`r af$ats.birthyr[x]`) som alltså än en gång framstår som otillförlitligt. Åldersangivelsen tas bort:

```{r}
af$age[x] <- NA
```

Se vidare avsnitt [-@sec:deskriptiv-statistik] för redovisning av ålder och övrig deskriptiv statistik.

## Kön

I det här sammanhanget handlar kön om juridiskt kön och ingenting annat.

```{r echo=FALSE}
kable(table(af$ats.sex,af$vts.sex), caption="Fyrfältstabell av kön i ATS respektive VTS.")
```

Kön finns i `ats.sex` och `vts.sex`. Om man ställer variablerna mot varandra i en fyrfältstabell framgår att ett antal personer är kodade som män i det ena systemet och kvinnor i det andra. Detta är uppenbara felregistreringar och det rimligaste är att helt enkelt ta bort dem.

```{r}
sex.mismatch <- af$ats.sex != af$vts.sex
af$ats.sex[sex.mismatch] <- NA
af$vts.sex[sex.mismatch] <- NA
```

Efter denna städning kan vi göra en variabel `gender` som innehåller juridiskt kön från antingen ATS eller VTS:

```{r}
af$gender <- af$ats.sex
af$gender[is.na(af$gender)] <- af$vts.sex[is.na(af$gender)]
```

```{r echo=FALSE}
gender.male <- af$gender=='Man'
gender.female <- af$gender=='Kvinna'
gender.known <- af$gender=='Man' | af$gender=='Kvinna'
n.male <- length(na.omit(af$gender[af$gender=='Man']))
n.female <- length(na.omit(af$gender[af$gender=='Kvinna']))
n.na <- length(af$gender[is.na(af$gender)])
```

Se vidare avsnitt [-@sec:deskriptiv-statistik] för redovisning av kön och övrig deskriptiv statistik.

## Utbildningsnivå

Precis som med kön är utbildningsnivå i vissa fall inkonsekvent kodat i ATS respektive VTS (se Tabell [-@tbl:edlevel.xtab]).

```{r echo=FALSE}
kable(table(af$ats.edlevel,af$vts.edlevel), caption="Angiven utbildningsnivå i ATS respektive VTS. {#tbl:edlevel.xtab}")
```

Liksom för kön tas de med olika kordning bort, dock med undantaget att om utbildningsnå är `Okänd` i endera ATS eller VTS används upgifterna från det andra systemet.

```{r}
# Sätt okända i ATS till VTS-värdet
subset <- af$ats.edlevel=='Okänd' & !is.na(af$ats.edlevel) & !is.na(af$vts.edlevel)
af$ats.edlevel[subset] <- af$vts.edlevel[subset]
# Sätt okända i VTS till ATS-värdet
subset <- af$vts.edlevel=='Okänd' & !is.na(af$ats.edlevel) & !is.na(af$vts.edlevel)
af$vts.edlevel[subset] <- af$ats.edlevel[subset]
# Radera felkodningar
subset <- af$ats.edlevel != af$vts.edlevel
af$ats.edlevel[subset] <- NA
af$vts.edlevel[subset] <- NA
rm(subset)
```

Efter denna städning kan vi göra en variabel `edlevel` som innehåller juridiskt kön från antingen ATS eller VTS:

```{r}
af$edlevel <- af$ats.edlevel
af$edlevel[is.na(af$edlevel)] <- af$vts.edlevel[is.na(af$edlevel)]
```


```{r echo=FALSE}
kable(count(af$edlevel), caption="Utbildningsnivå. {#tbl:edlevel}", col.names=c("Utbildningsnivå","N"))
```

Som framgår av Tabell [-@tbl:edlevel] är en övervägande del utbildningsnivå EU2 (grundskola/9 år) och EU3 (yrkesgymnasium/11 år). Ett iögonenfallande mönster framträder dock om man undersöker könsfördelningen på de olika utbildningsnivåerna (se Tabell [-@tbl:edlevel.gender]). Andelen kvinnor ökar med stigande utbildningsnivå. Detta blir tydligt 

```{r echo=FALSE}
t <- table(af$edlevel, af$gender)
# lägg till en kolumn med kvoten
t <- cbind(t,round(t[,2]/t[,1],2))
t <- cbind(t,round(t[,1]/(t[,1]+t[,2]),2))
colnames(t)[3] <- "Kvot"
colnames(t)[4] <- "Andel"
kable(t, caption="Utbildningsnivå fördelat på kön (där det finns angivet). {#tbl:edlevel.gender}")
rm(t)
```


```{r echo=FALSE}
plot(table(af$edlevel,af$gender), col=c("red","blue"))
```


# Deskriptiv statistik {#sec:deskriptiv-statistik}

```{r fig:age, fig.cap="Fördelning av ålder.", echo=FALSE}
plot(factor(af$age, levels=min(na.omit(af$age)):max(na.omit(af$age))))
```

Den första frågan man måste ställa sig är om juridiskt kön (som det handlar om här) över huvud taget är intressant i sammanhanget. I exempelvis manualen för ATS [@ATS551] redovisas separata normer för män och kvinnor utan att något egentligt skäl anges. Jag gissar att det har att göra med psykologiämnets långa tradition av att betrakta kön som en variabel snarare än gedigen reflektion [se t. ex. @MagnussonMarecek2010].

Datafilen innehåller då `r n.male` män (`r round(n.male/N*100)`%), `r n.female` kvinnor (`r round(n.female/N*100)`%) och `r n.na` okända (`r round(n.na/N*100)`%). Om man bortser från de okända är könsfördelningen `r round(n.male/(N-n.na)*100)`% män och `r round(n.female/(N-n.na)*100)`% kvinnor, vilket kan jämföras med *Testdata från APU* som uppger 42% kvinnor och 58% män [@LindskogTimstedtOhrstedt2017]. I datafilen är förhållandet män--kvinnor alltså 3:2, dvs. det går 1½ man på varje kvinna. Det finns anledning att fråga sig vad som ligger bakom en så uppenbart skev könsfördelning. *Hur kommer det sig att 50% fler män än kvinnor får del av en av Arbetsförmedlingens specialistinsatser, nämligen arbetspsykologisk utredning?*



# ATS

## Logisk förmåga (R), allmän intelligens, kognitiv förmåga, logik

### Formlogik

Table: Normdata för *Formlogik*, EU 3 och EU4 [@ATS55 66].

|     |          | *N*  | *M*   | *s*  |
|-----|----------|------|-------|------|
| EU3 | Samtliga | 1878 | 12,28 | 5,37 |
|     | Män      | 1386 | 12,34 | 5,38 |
|     | Kvinnor  | 492  | 12,10 | 5,34 |
| EU4 | Samtliga | 1008 | 15,39 | 5,08 |
|     | Män      | 710  | 15,45 | 5,00 |
|     | Kvinnor  | 298  | 15,23 | 5,27 |





Table: Data för *Formlogik*.

|            | *N*                     | *M* |
| ---------: | ---:                    |     |
| Samtliga   | `r mean(af$ats.dformr)` |     |

# Referenser
